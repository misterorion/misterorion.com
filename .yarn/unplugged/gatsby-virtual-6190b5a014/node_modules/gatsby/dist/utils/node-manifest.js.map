{"version":3,"file":"node-manifest.js","names":["getNodeManifestFileLimit","defaultLimit","overrideLimit","process","env","NODE_MANIFEST_FILE_LIMIT","Number","findPageOwnedByNode","nodeId","fullNode","slug","state","store","getState","pages","staticQueryComponents","byNode","byConnection","trackedComponents","queries","nodeType","internal","type","firstPagePathWithNodeAsDataDependency","get","values","next","value","firstPagePathWithNodeInGraphQLListField","pagePath","startsWith","staticQueryComponentPath","componentPath","firstPagePathUsingStaticQueryComponent","foundPageBy","ownerPagePath","foundOwnerNodeId","pageObject","path","fullPage","ownerNodeId","foundPageIdInContext","context","id","foundPageSlugInContext","pageCreatedByPluginName","getNode","pluginCreatorId","name","pageCreatedByFilesystemPlugin","page","foundPageByToLogIds","none","queryTracking","warnAboutNodeManifestMappingProblems","inputManifest","verbose","logId","reporter","error","Error","processNodeManifest","listOfUniqueErrorIds","nodeManifestPagePathMap","verboseLogs","previouslyWrittenNodeManifests","node","noNodeWarningId","pluginName","add","nodeManifestPage","nodeManifestMappingProblemsContext","finalManifest","gatsbySiteDirectory","program","directory","fileNameBase","manifestId","platform","replace","manifestFilePath","join","manifestFileDir","dirname","fs","ensureDir","previouslyWrittenNodeManifest","shouldWriteManifest","writePromise","writeJSON","set","Promise","resolve","then","info","nodeManifestSortComparerAscendingUpdatedAt","a","b","updatedAtUTC","Date","parse","processNodeManifests","gatsby_log_level","VERBOSE_NODE_MANIFEST","startTime","now","nodeManifests","totalManifests","length","totalProcessedManifests","totalFailedManifests","Map","Set","processNodeManifestTask","manifest","cb","processedManifest","setImmediate","processNodeManifestQueue","fastq","sort","slice","push","idle","drain","pluralize","endTime","size","dispatch","internalActions","deleteNodeManifests"],"sources":["../../src/utils/node-manifest.ts"],"sourcesContent":["import type { ErrorId } from \"gatsby-cli/lib/structured-errors/error-map\"\nimport { getNode } from \"./../datastore\"\nimport { IGatsbyNode, IGatsbyPage, INodeManifest } from \"./../redux/types\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { store } from \"../redux/\"\nimport { internalActions } from \"../redux/actions\"\nimport path from \"path\"\nimport fs from \"fs-extra\"\nimport fastq from \"fastq\"\n\ninterface INodeManifestPage {\n  path?: string\n}\n\n/**\n * This it the output after processing calls to the public unstable_createNodeManifest action\n */\ninterface INodeManifestOut {\n  page: INodeManifestPage\n  node: {\n    id: string\n  }\n  foundPageBy: FoundPageBy\n}\n\ntype FoundPageBy =\n  | `ownerNodeId`\n  | `filesystem-route-api`\n  // for these three we warn to use ownerNodeId instead\n  | `context.id`\n  | `context.slug`\n  | `queryTracking`\n  | `none`\n\ntype PreviouslyWrittenNodeManifests = Map<string, Promise<INodeManifestOut>>\n\nfunction getNodeManifestFileLimit(): number {\n  const defaultLimit = 10000\n\n  const overrideLimit =\n    process.env.NODE_MANIFEST_FILE_LIMIT &&\n    Number(process.env.NODE_MANIFEST_FILE_LIMIT)\n\n  return overrideLimit || defaultLimit\n}\n/**\n * This defines a limit to the number number of node manifest files that will be written to disk\n */\nconst NODE_MANIFEST_FILE_LIMIT = getNodeManifestFileLimit()\n\n/**\n * Finds a final built page by nodeId or by node.slug as a fallback.\n *\n * Note that this function wont work properly in `gatsby develop`\n * since develop no longer runs all page queries when creating pages.\n * We use the node id to query mapping to find the right page but\n * this mapping only exists once you've visited a page in your browser.\n * When this fn is being used for routing to previews the user wont necessarily have\n * visited the page in the browser yet.\n */\nasync function findPageOwnedByNode({\n  nodeId,\n  fullNode,\n  slug,\n}: {\n  nodeId: string\n  fullNode: IGatsbyNode\n  slug?: string\n}): Promise<{\n  page: INodeManifestPage\n  foundPageBy: FoundPageBy\n}> {\n  const state = store.getState()\n  const { pages, staticQueryComponents } = state\n  const { byNode, byConnection, trackedComponents } = state.queries\n\n  const nodeType = fullNode?.internal?.type\n\n  const firstPagePathWithNodeAsDataDependency =\n    // the first page found in node id to page query path tracking\n    byNode?.get(nodeId)?.values()?.next()?.value\n\n  const firstPagePathWithNodeInGraphQLListField =\n    // the first page that queries for a list of this node type.\n    // we don't currently store a list of node ids for connection fields to queries\n    // we just store the query id or page path mapped to the connected GraphQL typename.\n    byConnection?.get(nodeType)?.values()?.next()?.value\n\n  let pagePath =\n    firstPagePathWithNodeAsDataDependency ||\n    firstPagePathWithNodeInGraphQLListField\n\n  // for static queries, we can only find the first page using that static query\n  // the reason we would find `sq--` here is because byConnection (above) can return a page path or a static query ID (which starts with `sq--`)\n  if (pagePath?.startsWith(`sq--`)) {\n    const staticQueryComponentPath =\n      staticQueryComponents?.get(pagePath)?.componentPath\n\n    const firstPagePathUsingStaticQueryComponent: string | null =\n      staticQueryComponentPath\n        ? trackedComponents\n            ?.get(staticQueryComponentPath)\n            ?.pages?.values()\n            ?.next()?.value\n        : null\n\n    pagePath = firstPagePathUsingStaticQueryComponent\n  }\n\n  let foundPageBy: FoundPageBy = pagePath ? `queryTracking` : `none`\n\n  if (pages) {\n    let ownerPagePath: string | undefined\n    let foundOwnerNodeId = false\n\n    // for each page this nodeId is queried in\n    for (const pageObject of pages.values()) {\n      // if we haven't found a page with this nodeId\n      // set as page.ownerNodeId then run this logic.\n      // this condition is on foundOwnerNodeId instead of ownerPagePath\n      // in case we find a page with the nodeId in page.context.id/context.slug\n      // and then later in the loop there's a page with this nodeId\n      // set on page.ownerNodeId.\n      // We always want to prefer ownerPagePath over context.id/context.slug\n      if (foundOwnerNodeId) {\n        break\n      }\n\n      const path = pageObject.path\n\n      const fullPage: IGatsbyPage | undefined = pages.get(path)\n\n      foundOwnerNodeId = fullPage?.ownerNodeId === nodeId\n\n      const foundPageIdInContext = fullPage?.context?.id === nodeId\n\n      // querying by node.slug in GraphQL queries is common enough that we can search for it as a fallback after ownerNodeId, filesystem routes, and context.id\n      const foundPageSlugInContext = slug && fullPage?.context?.slug === slug\n\n      if (foundOwnerNodeId) {\n        foundPageBy = `ownerNodeId`\n      } else if (foundPageIdInContext && fullPage) {\n        const pageCreatedByPluginName = getNode(fullPage.pluginCreatorId)?.name\n\n        const pageCreatedByFilesystemPlugin =\n          pageCreatedByPluginName === `gatsby-plugin-page-creator`\n\n        foundPageBy = pageCreatedByFilesystemPlugin\n          ? `filesystem-route-api`\n          : `context.id`\n      } else if (foundPageSlugInContext && fullPage) {\n        foundPageBy = `context.slug`\n      }\n\n      if (\n        fullPage &&\n        // first check for the ownerNodeId on the page. this is\n        // the defacto owner. Can't get more specific than this\n        (foundOwnerNodeId ||\n          // if there's no specified owner look to see if\n          // pageContext has an `id` variable which matches our\n          // nodeId. Using an \"id\" as a variable in queries is common\n          // and if we don't have an owner this is a better guess\n          // of an owner than grabbing the first page query we find\n          // that's mapped to this node id.\n          // this also makes this work with the filesystem Route API without\n          // changing that API.\n          foundPageIdInContext ||\n          foundPageSlugInContext)\n      ) {\n        // save this path to use in our manifest!\n        ownerPagePath = fullPage.path\n      }\n    }\n\n    if (ownerPagePath) {\n      pagePath = ownerPagePath\n    }\n  }\n\n  return {\n    page: {\n      path: pagePath || null,\n    },\n    foundPageBy,\n  }\n}\n\n// these id's correspond to error id's in\n// packages/gatsby-cli/src/structured-errors/error-map.ts\nexport const foundPageByToLogIds = {\n  none: `11801`,\n  [`context.id`]: `11802`,\n  [`context.slug`]: `11805`,\n  queryTracking: `11803`,\n  [`filesystem-route-api`]: `success`,\n  ownerNodeId: `success`,\n}\n\n/**\n * Takes in some info about a node manifest and the page we did or didn't find for it, then warns and returns the warning string\n */\nexport function warnAboutNodeManifestMappingProblems({\n  inputManifest,\n  pagePath,\n  foundPageBy,\n  verbose,\n}: {\n  inputManifest: INodeManifest\n  pagePath?: string\n  foundPageBy: FoundPageBy\n  verbose: boolean\n}): { logId: string } {\n  let logId: ErrorId | `success`\n\n  switch (foundPageBy) {\n    case `none`:\n    case `context.id`:\n    case `context.slug`:\n    case `queryTracking`: {\n      logId = foundPageByToLogIds[foundPageBy]\n      if (verbose) {\n        reporter.error({\n          id: logId,\n          context: {\n            inputManifest,\n            pagePath,\n          },\n        })\n      }\n      break\n    }\n\n    case `filesystem-route-api`:\n    case `ownerNodeId`:\n      logId = `success`\n      break\n\n    default: {\n      throw Error(`Node Manifest mapping is in an impossible state`)\n    }\n  }\n\n  return {\n    logId,\n  }\n}\n\n/**\n * Prepares and then writes out an individual node manifest file to be used for routing to previews. Manifest files are added via the public unstable_createNodeManifest action\n */\nexport async function processNodeManifest(\n  inputManifest: INodeManifest,\n  listOfUniqueErrorIds: Set<string>,\n  nodeManifestPagePathMap: Map<string, string>,\n  verboseLogs: boolean,\n  previouslyWrittenNodeManifests: PreviouslyWrittenNodeManifests\n): Promise<null | INodeManifestOut> {\n  const nodeId = inputManifest.node.id\n  const fullNode = getNode(nodeId)\n  const noNodeWarningId = `11804`\n\n  if (!fullNode) {\n    if (verboseLogs) {\n      reporter.error({\n        id: noNodeWarningId,\n        context: {\n          pluginName: inputManifest.pluginName,\n          nodeId,\n        },\n      })\n    } else {\n      listOfUniqueErrorIds.add(noNodeWarningId)\n    }\n\n    return null\n  }\n\n  // map the node to a page that was created\n  const { page: nodeManifestPage, foundPageBy } = await findPageOwnedByNode({\n    nodeId,\n    fullNode,\n    // querying by node.slug in GraphQL queries is common enough that we can search for it as a fallback after ownerNodeId, filesystem routes, and context.id\n    slug: fullNode?.slug as string,\n  })\n\n  const nodeManifestMappingProblemsContext = {\n    inputManifest,\n    pagePath: nodeManifestPage.path,\n    foundPageBy,\n    verbose: verboseLogs,\n  }\n\n  if (verboseLogs) {\n    warnAboutNodeManifestMappingProblems(nodeManifestMappingProblemsContext)\n  } else {\n    const { logId } = warnAboutNodeManifestMappingProblems(\n      nodeManifestMappingProblemsContext\n    )\n\n    if (logId !== `success`) {\n      listOfUniqueErrorIds.add(logId)\n    }\n  }\n\n  const finalManifest: INodeManifestOut = {\n    node: inputManifest.node,\n    page: nodeManifestPage,\n    foundPageBy,\n  }\n\n  const gatsbySiteDirectory = store.getState().program.directory\n\n  let fileNameBase = inputManifest.manifestId\n\n  /**\n   * Windows has a handful of special/reserved characters that are not valid in a file path\n   * @reference https://superuser.com/questions/358855/what-characters-are-safe-in-cross-platform-file-names-for-linux-windows-and-os\n   *\n   * The two exceptions to the list linked above are\n   * - the colon that is part of the hard disk partition name at the beginning of a file path (i.e. C:)\n   * - backslashes. We don't want to replace backslashes because those are used to delineate what the actual file path is\n   *\n   * During local development, node manifests can be written to disk but are generally unused as they are only used\n   * for Content Sync which runs in Gatsby Cloud. Gatsby cloud is a Linux environment in which these special chars are valid in\n   * filepaths. To avoid errors on Windows, we replace all instances of the special chars in the filepath (with the exception of the\n   * hard disk partition name) with \"-\" to ensure that local Windows development setups do not break when attempting\n   * to write one of these manifests to disk.\n   */\n  if (process.platform === `win32`) {\n    fileNameBase = fileNameBase.replace(/:|\\/|\\*|\\?|\"|<|>|\\||\\\\/g, `-`)\n  }\n\n  // write out the manifest file\n  const manifestFilePath = path.join(\n    gatsbySiteDirectory,\n    `public`,\n    `__node-manifests`,\n    inputManifest.pluginName,\n    `${fileNameBase}.json`\n  )\n\n  const manifestFileDir = path.dirname(manifestFilePath)\n\n  await fs.ensureDir(manifestFileDir)\n\n  const previouslyWrittenNodeManifest =\n    await previouslyWrittenNodeManifests.get(inputManifest.manifestId)\n\n  // write a manifest if we don't currently have one written for this ID\n  // or if we can replace the written one with a manifest that has found a page\n  // NOTE: We still want to write out a manifest if foundPageBy is \"none\", this helps with error messaging\n  //       But we prefer to write a manifest that has a foundPageBy that is NOT \"none\"\n  const shouldWriteManifest =\n    !previouslyWrittenNodeManifest ||\n    (previouslyWrittenNodeManifest?.foundPageBy === `none` &&\n      finalManifest.foundPageBy !== `none`)\n\n  if (shouldWriteManifest) {\n    const writePromise = fs.writeJSON(manifestFilePath, finalManifest)\n\n    // This prevents two manifests from writing to the same file at the same time\n    previouslyWrittenNodeManifests.set(\n      inputManifest.manifestId,\n      new Promise(resolve => {\n        writePromise.then(() => {\n          resolve(finalManifest)\n        })\n      })\n    )\n\n    await writePromise\n  }\n\n  if (shouldWriteManifest && verboseLogs) {\n    reporter.info(\n      `Plugin ${inputManifest.pluginName} created a manifest with the id ${fileNameBase}`\n    )\n  } else if (verboseLogs) {\n    reporter.info(\n      `Plugin ${inputManifest.pluginName} created a manifest with the id ${fileNameBase} but it was not written to disk because it was already written to disk previously.`\n    )\n  }\n\n  if (nodeManifestPage.path) {\n    nodeManifestPagePathMap.set(nodeManifestPage.path, fileNameBase)\n  }\n\n  return finalManifest\n}\n\nfunction nodeManifestSortComparerAscendingUpdatedAt(a, b): number {\n  /**\n   * Prioritize node manifests that have an updatedAtUTC so that manifests known to be\n   * newest are written to disk first. If neither have an updatedAtUTC, there isn't\n   * anything to sort\n   */\n  if (!a.updatedAtUTC && !b.updatedAtUTC) {\n    return 0\n  }\n\n  if (!a.updatedAtUTC) {\n    return 1\n  }\n\n  if (!b.updatedAtUTC) {\n    return -1\n  }\n\n  return Date.parse(a.updatedAtUTC) - Date.parse(b.updatedAtUTC)\n}\n\n/**\n * Grabs all pending node manifests, processes them, writes them to disk,\n * and then removes them from the store.\n * Manifest files are added via the public unstable_createNodeManifest action in sourceNodes\n */\nexport async function processNodeManifests(): Promise<Map<\n  string,\n  string\n> | null> {\n  const verboseLogs =\n    process.env.gatsby_log_level === `verbose` ||\n    process.env.VERBOSE_NODE_MANIFEST === `true`\n\n  const startTime = Date.now()\n  let { nodeManifests } = store.getState()\n\n  const totalManifests = nodeManifests.length\n\n  if (totalManifests === 0) {\n    return null\n  }\n\n  let totalProcessedManifests = 0\n  let totalFailedManifests = 0\n  const nodeManifestPagePathMap: Map<string, string> = new Map()\n  const listOfUniqueErrorIds: Set<string> = new Set()\n  const previouslyWrittenNodeManifests: PreviouslyWrittenNodeManifests =\n    new Map()\n\n  async function processNodeManifestTask(\n    manifest: INodeManifest,\n    cb: fastq.done<any>\n  ): Promise<void> {\n    const processedManifest = await processNodeManifest(\n      manifest,\n      listOfUniqueErrorIds,\n      nodeManifestPagePathMap,\n      verboseLogs,\n      previouslyWrittenNodeManifests\n    )\n\n    if (processedManifest) {\n      totalProcessedManifests++\n    } else {\n      totalFailedManifests++\n    }\n\n    // `setImmediate` below is a workaround against stack overflow\n    // occurring when there are many manifests\n    setImmediate(() => cb(null, true))\n    return\n  }\n\n  const processNodeManifestQueue = fastq(processNodeManifestTask, 25)\n\n  if (totalManifests > NODE_MANIFEST_FILE_LIMIT) {\n    nodeManifests = [...nodeManifests]\n    nodeManifests.sort(nodeManifestSortComparerAscendingUpdatedAt)\n    nodeManifests = nodeManifests.slice(0, NODE_MANIFEST_FILE_LIMIT)\n  }\n\n  for (const manifest of nodeManifests) {\n    processNodeManifestQueue.push(manifest, () => {})\n  }\n\n  if (!processNodeManifestQueue.idle()) {\n    await new Promise(resolve => {\n      processNodeManifestQueue.drain = resolve as () => unknown\n    })\n  }\n\n  const pluralize = (length: number): string =>\n    length > 1 || length === 0 ? `s` : ``\n\n  const endTime = Date.now()\n\n  reporter.info(\n    `Wrote out ${totalProcessedManifests} node page manifest file${pluralize(\n      totalProcessedManifests\n    )} in ${endTime - startTime} ms. ${\n      totalFailedManifests > 0\n        ? `. ${totalFailedManifests} manifest${pluralize(\n            totalFailedManifests\n          )} couldn't be processed.`\n        : ``\n    }`\n  )\n\n  reporter.info(\n    (!verboseLogs && listOfUniqueErrorIds.size > 0\n      ? `unstable_createNodeManifest produced warnings [${[\n          ...listOfUniqueErrorIds,\n        ].join(`, `)}]. `\n      : ``) +\n      `To see full warning messages set process.env.VERBOSE_NODE_MANIFEST to \"true\".\\nVisit https://gatsby.dev/nodemanifest for more info on Node Manifests.`\n  )\n\n  // clean up all pending manifests from the store\n  store.dispatch(internalActions.deleteNodeManifests())\n  return nodeManifestPagePathMap\n}\n"],"mappings":"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"}