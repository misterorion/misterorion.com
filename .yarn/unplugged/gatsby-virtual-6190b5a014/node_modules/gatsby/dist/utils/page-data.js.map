{"version":3,"file":"page-data.js","names":["readPageData","publicDir","pagePath","filePath","generatePageDataPath","rawPageData","fs","readFile","JSON","parse","removePageData","existsSync","remove","Promise","resolve","pageDataExists","lmdbPageQueryResultsCache","getLMDBPageQueryResultsCache","GatsbyCacheLmdbImpl","require","default","name","encoding","init","savePageQueryResultsPromise","waitUntilPageQueryResultsAreStored","savePageQueryResult","stringifiedResult","set","readPageQueryResult","get","Error","writePageData","pageData","slicesUsedByTemplates","slices","result","path","outputFilePath","body","constructPageDataString","pageDataSize","Buffer","byteLength","store","dispatch","type","payload","size","pageDataHash","createContentDigest","ensureFileContent","writeSliceData","componentChunkName","staticQueryHashes","toString","join","sliceData","stringify","sliceDataSize","sliceName","sliceDataHash","readSliceData","isFlushPending","isFlushing","isFlushEnqueued","flush","parentSpan","pendingPageDataWrites","pages","program","staticQueriesByTemplate","queries","slicesByTemplate","getState","isBuild","_","pagePaths","sliceNames","writePageDataActivity","nodeManifestPagePathMap","processNodeManifests","reporter","createProgress","id","start","flushQueue","fastq","task","cb","page","shouldClearPendingWrite","manifestId","process","env","GATSBY_QUERY_ON_DEMAND","query","trackedQueries","hasFlag","dirty","FLAG_DIRTY_NEW_PAGE","setImmediate","getPageMode","componentPath","directory","websocketManager","emitPageData","e","panicOnBuild","tick","slice","emitSliceData","push","idle","drain","end","enqueueFlush","isWebpackStatusPending","handleStalePageData","pathExists","activity","activityTimer","pageDataFilesFromPreviousBuilds","reject","results","Set","stream","fsWalkStream","on","data","add","expectedPageDataFiles","forEach","deletionPromises","pageDataFilePath","has","all"],"sources":["../../src/utils/page-data.ts"],"sourcesContent":["import { walkStream as fsWalkStream, Entry } from \"@nodelib/fs.walk\"\nimport fs from \"fs-extra\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport fastq from \"fastq\"\nimport path from \"path\"\nimport { createContentDigest, generatePageDataPath } from \"gatsby-core-utils\"\nimport { websocketManager } from \"./websocket-manager\"\nimport { isWebpackStatusPending } from \"./webpack-status\"\nimport { store } from \"../redux\"\nimport type { IGatsbySlice, IGatsbyState } from \"../redux/types\"\nimport { hasFlag, FLAG_DIRTY_NEW_PAGE } from \"../redux/reducers/queries\"\nimport type GatsbyCacheLmdb from \"./cache-lmdb\"\nimport {\n  constructPageDataString,\n  reverseFixedPagePath,\n  IPageData,\n  IPageDataInput,\n} from \"./page-data-helpers\"\nimport { Span } from \"opentracing\"\n\nexport { reverseFixedPagePath }\nimport { processNodeManifests } from \"../utils/node-manifest\"\nimport { IExecutionResult } from \"../query/types\"\nimport { getPageMode } from \"./page-mode\"\nimport { ICollectedSlices } from \"./babel/find-slices\"\nimport { ensureFileContent } from \"./ensure-file-content\"\n\nexport interface IPageDataWithQueryResult extends IPageData {\n  result: IExecutionResult\n}\n\nexport interface ISliceData {\n  componentChunkName: string\n  result: IExecutionResult\n  staticQueryHashes: Array<string>\n}\n\nexport async function readPageData(\n  publicDir: string,\n  pagePath: string\n): Promise<IPageDataWithQueryResult> {\n  const filePath = generatePageDataPath(publicDir, pagePath)\n  const rawPageData = await fs.readFile(filePath, `utf-8`)\n  return JSON.parse(rawPageData)\n}\n\nexport async function removePageData(\n  publicDir: string,\n  pagePath: string\n): Promise<void> {\n  const filePath = generatePageDataPath(publicDir, pagePath)\n\n  if (fs.existsSync(filePath)) {\n    return await fs.remove(filePath)\n  }\n\n  return Promise.resolve()\n}\n\nexport function pageDataExists(publicDir: string, pagePath: string): boolean {\n  return fs.existsSync(generatePageDataPath(publicDir, pagePath))\n}\n\nlet lmdbPageQueryResultsCache: GatsbyCacheLmdb\nfunction getLMDBPageQueryResultsCache(): GatsbyCacheLmdb {\n  if (!lmdbPageQueryResultsCache) {\n    const GatsbyCacheLmdbImpl = require(`./cache-lmdb`).default\n    lmdbPageQueryResultsCache = new GatsbyCacheLmdbImpl({\n      name: `internal-tmp-query-results`,\n      encoding: `string`,\n    }).init()\n  }\n  return lmdbPageQueryResultsCache\n}\n\nlet savePageQueryResultsPromise = Promise.resolve()\n\nexport function waitUntilPageQueryResultsAreStored(): Promise<void> {\n  return savePageQueryResultsPromise\n}\n\nexport async function savePageQueryResult(\n  pagePath: string,\n  stringifiedResult: string\n): Promise<void> {\n  savePageQueryResultsPromise = getLMDBPageQueryResultsCache().set(\n    pagePath,\n    stringifiedResult\n  ) as Promise<void>\n}\n\nexport async function readPageQueryResult(pagePath: string): Promise<string> {\n  const stringifiedResult = await getLMDBPageQueryResultsCache().get(pagePath)\n  if (typeof stringifiedResult === `string`) {\n    return stringifiedResult\n  }\n  throw new Error(`Couldn't find temp query result for \"${pagePath}\".`)\n}\n\nexport async function writePageData(\n  publicDir: string,\n  pageData: IPageDataInput,\n  slicesUsedByTemplates: Map<string, ICollectedSlices>,\n  slices: IGatsbyState[\"slices\"]\n): Promise<string> {\n  const result = await readPageQueryResult(pageData.path)\n\n  const outputFilePath = generatePageDataPath(publicDir, pageData.path)\n\n  const body = constructPageDataString(\n    pageData,\n    result,\n    slicesUsedByTemplates,\n    slices\n  )\n\n  // transform asset size to kB (from bytes) to fit 64 bit to numbers\n  const pageDataSize = Buffer.byteLength(body) / 1000\n\n  store.dispatch({\n    type: `ADD_PAGE_DATA_STATS`,\n    payload: {\n      pagePath: pageData.path,\n      filePath: outputFilePath,\n      size: pageDataSize,\n      pageDataHash: createContentDigest(body),\n    },\n  })\n\n  await ensureFileContent(outputFilePath, body)\n  return body\n}\n\nexport async function writeSliceData(\n  publicDir: string,\n  { componentChunkName, name }: IGatsbySlice,\n  staticQueryHashes: Array<string>\n): Promise<string> {\n  const result = JSON.parse(\n    (await readPageQueryResult(`slice--${name}`)).toString()\n  )\n\n  const outputFilePath = path.join(publicDir, `slice-data`, `${name}.json`)\n\n  const sliceData: ISliceData = {\n    componentChunkName,\n    result,\n    staticQueryHashes,\n  }\n\n  const body = JSON.stringify(sliceData)\n\n  const sliceDataSize = Buffer.byteLength(body) / 1000\n\n  store.dispatch({\n    type: `ADD_SLICE_DATA_STATS`,\n    payload: {\n      sliceName: name,\n      filePath: outputFilePath,\n      size: sliceDataSize,\n      sliceDataHash: createContentDigest(body),\n    },\n  })\n\n  await ensureFileContent(outputFilePath, body)\n  return body\n}\n\nexport async function readSliceData(\n  publicDir: string,\n  sliceName: string\n): Promise<IPageDataWithQueryResult> {\n  const filePath = path.join(publicDir, `slice-data`, `${sliceName}.json`)\n  const rawPageData = await fs.readFile(filePath, `utf-8`)\n  return JSON.parse(rawPageData)\n}\n\nlet isFlushPending = false\nlet isFlushing = false\n\nexport function isFlushEnqueued(): boolean {\n  return isFlushPending\n}\n\ntype IDataTask =\n  | {\n      type: \"page\"\n      pagePath: string\n    }\n  | {\n      type: \"slice\"\n      sliceName: string\n    }\n\nexport async function flush(parentSpan?: Span): Promise<void> {\n  if (isFlushing) {\n    // We're already in the middle of a flush\n    return\n  }\n  await waitUntilPageQueryResultsAreStored()\n  isFlushPending = false\n  isFlushing = true\n  const {\n    pendingPageDataWrites,\n    pages,\n    program,\n    staticQueriesByTemplate,\n    queries,\n    slices,\n    slicesByTemplate,\n  } = store.getState()\n  const isBuild = program?._?.[0] !== `develop`\n\n  const { pagePaths, sliceNames } = pendingPageDataWrites\n  let writePageDataActivity\n\n  let nodeManifestPagePathMap\n\n  if (pagePaths.size > 0) {\n    // we process node manifests in this location because we need to add the manifestId to the page data.\n    // We use this manifestId to determine if the page data is up to date when routing. Here we create a map of \"pagePath\": \"manifestId\" while processing and writing node manifest files.\n    // We only do this when there are pending page-data writes because otherwise we could flush pending createNodeManifest calls before page-data.json files are written. Which means those page-data files wouldn't have the corresponding manifest id's written to them.\n    nodeManifestPagePathMap = await processNodeManifests()\n  }\n\n  if (pagePaths.size > 0 || sliceNames.size > 0) {\n    writePageDataActivity = reporter.createProgress(\n      `Writing page-data.json and slice-data.json files to public directory`,\n      pagePaths.size + sliceNames.size,\n      0,\n      { id: `write-page-data-public-directory`, parentSpan }\n    )\n    writePageDataActivity.start()\n  }\n\n  const flushQueue = fastq<void, IDataTask, boolean>(async (task, cb) => {\n    if (task.type === `page`) {\n      const { pagePath } = task\n      const page = pages.get(pagePath)\n\n      let shouldClearPendingWrite = true\n\n      // It's a gloomy day in Bombay, let me tell you a short story...\n      // Once upon a time, writing page-data.json files were atomic\n      // After this change (#24808), they are not and this means that\n      // between adding a pending write for a page and actually flushing\n      // them, a page might not exist anymore щ（ﾟДﾟщ）\n      // This is why we need this check\n      if (page) {\n        if (page.path && nodeManifestPagePathMap) {\n          page.manifestId = nodeManifestPagePathMap.get(page.path)\n        }\n\n        if (!isBuild && process.env.GATSBY_QUERY_ON_DEMAND) {\n          // check if already did run query for this page\n          // with query-on-demand we might have pending page-data write due to\n          // changes in static queries assigned to page template, but we might not\n          // have query result for it\n          const query = queries.trackedQueries.get(page.path)\n          if (!query) {\n            // this should not happen ever\n            throw new Error(\n              `We have a page, but we don't have registered query for it (???)`\n            )\n          }\n\n          if (hasFlag(query.dirty, FLAG_DIRTY_NEW_PAGE)) {\n            // query results are not written yet\n            setImmediate(() => cb(null, true))\n            return\n          }\n        }\n\n        // In develop we rely on QUERY_ON_DEMAND so we just go through\n        // In build we only build these page-json for SSG pages\n        if (!isBuild || (isBuild && getPageMode(page) === `SSG`)) {\n          const staticQueryHashes =\n            staticQueriesByTemplate.get(page.componentPath) || []\n\n          try {\n            const result = await writePageData(\n              path.join(program.directory, `public`),\n              {\n                ...page,\n                staticQueryHashes,\n              },\n              slicesByTemplate,\n              slices\n            )\n\n            if (!isBuild) {\n              websocketManager.emitPageData({\n                id: pagePath,\n                result: JSON.parse(result) as IPageDataWithQueryResult,\n              })\n            }\n          } catch (e) {\n            shouldClearPendingWrite = false\n            reporter.panicOnBuild(\n              `Failed to write page-data for \"\"${page.path}`,\n              e\n            )\n          }\n          writePageDataActivity.tick()\n        }\n      }\n\n      if (shouldClearPendingWrite) {\n        store.dispatch({\n          type: `CLEAR_PENDING_PAGE_DATA_WRITE`,\n          payload: {\n            page: pagePath,\n          },\n        })\n      }\n    } else if (task.type === `slice`) {\n      const { sliceName } = task\n      const slice = slices.get(sliceName)\n      if (slice) {\n        const staticQueryHashes =\n          staticQueriesByTemplate.get(slice.componentPath) || []\n\n        const result = await writeSliceData(\n          path.join(program.directory, `public`),\n          slice,\n          staticQueryHashes\n        )\n\n        writePageDataActivity.tick()\n\n        if (!isBuild) {\n          websocketManager.emitSliceData({\n            id: sliceName,\n            result: JSON.parse(result) as IPageDataWithQueryResult,\n          })\n        }\n      }\n\n      store.dispatch({\n        type: `CLEAR_PENDING_SLICE_DATA_WRITE`,\n        payload: {\n          name: sliceName,\n        },\n      })\n    }\n\n    // `setImmediate` below is a workaround against stack overflow\n    // occurring when there are many non-SSG pages\n    setImmediate(() => cb(null, true))\n    return\n  }, 25)\n\n  for (const pagePath of pagePaths) {\n    flushQueue.push({ type: `page`, pagePath }, () => {})\n  }\n  for (const sliceName of sliceNames) {\n    flushQueue.push({ type: `slice`, sliceName }, () => {})\n  }\n\n  if (!flushQueue.idle()) {\n    await new Promise(resolve => {\n      flushQueue.drain = resolve as () => unknown\n    })\n  }\n  if (writePageDataActivity) {\n    writePageDataActivity.end()\n  }\n\n  isFlushing = false\n\n  return\n}\n\nexport function enqueueFlush(parentSpan?: Span): void {\n  if (isWebpackStatusPending()) {\n    isFlushPending = true\n  } else {\n    flush(parentSpan)\n  }\n}\n\nexport async function handleStalePageData(parentSpan: Span): Promise<void> {\n  if (!(await fs.pathExists(`public/page-data`))) {\n    return\n  }\n\n  // public directory might have stale page-data files from previous builds\n  // we get the list of those and compare against expected page-data files\n  // and remove ones that shouldn't be there anymore\n\n  const activity = reporter.activityTimer(`Cleaning up stale page-data`, {\n    parentSpan,\n  })\n  activity.start()\n\n  const pageDataFilesFromPreviousBuilds = await new Promise<Set<string>>(\n    (resolve, reject) => {\n      const results = new Set<string>()\n\n      const stream = fsWalkStream(`public/page-data`)\n\n      stream.on(`data`, (data: Entry) => {\n        if (data.name === `page-data.json`) {\n          results.add(data.path)\n        }\n      })\n\n      stream.on(`error`, e => {\n        reject(e)\n      })\n\n      stream.on(`end`, () => resolve(results))\n    }\n  )\n\n  const expectedPageDataFiles = new Set<string>()\n  store.getState().pages.forEach(page => {\n    expectedPageDataFiles.add(generatePageDataPath(`public`, page.path))\n  })\n\n  const deletionPromises: Array<Promise<void>> = []\n  pageDataFilesFromPreviousBuilds.forEach(pageDataFilePath => {\n    if (!expectedPageDataFiles.has(pageDataFilePath)) {\n      deletionPromises.push(fs.remove(pageDataFilePath))\n    }\n  })\n\n  await Promise.all(deletionPromises)\n\n  activity.end()\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AAEA;;;;AASA;;AAEA;;AAEA;;AAYO,eAAeA,YAAf,CACLC,SADK,EAELC,QAFK,EAG8B;EACnC,MAAMC,QAAQ,GAAG,IAAAC,qCAAA,EAAqBH,SAArB,EAAgCC,QAAhC,CAAjB;EACA,MAAMG,WAAW,GAAG,MAAMC,gBAAA,CAAGC,QAAH,CAAYJ,QAAZ,EAAuB,OAAvB,CAA1B;EACA,OAAOK,IAAI,CAACC,KAAL,CAAWJ,WAAX,CAAP;AACD;;AAEM,eAAeK,cAAf,CACLT,SADK,EAELC,QAFK,EAGU;EACf,MAAMC,QAAQ,GAAG,IAAAC,qCAAA,EAAqBH,SAArB,EAAgCC,QAAhC,CAAjB;;EAEA,IAAII,gBAAA,CAAGK,UAAH,CAAcR,QAAd,CAAJ,EAA6B;IAC3B,OAAO,MAAMG,gBAAA,CAAGM,MAAH,CAAUT,QAAV,CAAb;EACD;;EAED,OAAOU,OAAO,CAACC,OAAR,EAAP;AACD;;AAEM,SAASC,cAAT,CAAwBd,SAAxB,EAA2CC,QAA3C,EAAsE;EAC3E,OAAOI,gBAAA,CAAGK,UAAH,CAAc,IAAAP,qCAAA,EAAqBH,SAArB,EAAgCC,QAAhC,CAAd,CAAP;AACD;;AAED,IAAIc,yBAAJ;;AACA,SAASC,4BAAT,GAAyD;EACvD,IAAI,CAACD,yBAAL,EAAgC;IAC9B,MAAME,mBAAmB,GAAGC,OAAO,CAAE,cAAF,CAAP,CAAwBC,OAApD;;IACAJ,yBAAyB,GAAG,IAAIE,mBAAJ,CAAwB;MAClDG,IAAI,EAAG,4BAD2C;MAElDC,QAAQ,EAAG;IAFuC,CAAxB,EAGzBC,IAHyB,EAA5B;EAID;;EACD,OAAOP,yBAAP;AACD;;AAED,IAAIQ,2BAA2B,GAAGX,OAAO,CAACC,OAAR,EAAlC;;AAEO,SAASW,kCAAT,GAA6D;EAClE,OAAOD,2BAAP;AACD;;AAEM,eAAeE,mBAAf,CACLxB,QADK,EAELyB,iBAFK,EAGU;EACfH,2BAA2B,GAAGP,4BAA4B,GAAGW,GAA/B,CAC5B1B,QAD4B,EAE5ByB,iBAF4B,CAA9B;AAID;;AAEM,eAAeE,mBAAf,CAAmC3B,QAAnC,EAAsE;EAC3E,MAAMyB,iBAAiB,GAAG,MAAMV,4BAA4B,GAAGa,GAA/B,CAAmC5B,QAAnC,CAAhC;;EACA,IAAI,OAAOyB,iBAAP,KAA8B,QAAlC,EAA2C;IACzC,OAAOA,iBAAP;EACD;;EACD,MAAM,IAAII,KAAJ,CAAW,wCAAuC7B,QAAS,IAA3D,CAAN;AACD;;AAEM,eAAe8B,aAAf,CACL/B,SADK,EAELgC,QAFK,EAGLC,qBAHK,EAILC,MAJK,EAKY;EACjB,MAAMC,MAAM,GAAG,MAAMP,mBAAmB,CAACI,QAAQ,CAACI,IAAV,CAAxC;EAEA,MAAMC,cAAc,GAAG,IAAAlC,qCAAA,EAAqBH,SAArB,EAAgCgC,QAAQ,CAACI,IAAzC,CAAvB;EAEA,MAAME,IAAI,GAAG,IAAAC,wCAAA,EACXP,QADW,EAEXG,MAFW,EAGXF,qBAHW,EAIXC,MAJW,CAAb,CALiB,CAYjB;;EACA,MAAMM,YAAY,GAAGC,MAAM,CAACC,UAAP,CAAkBJ,IAAlB,IAA0B,IAA/C;;EAEAK,YAAA,CAAMC,QAAN,CAAe;IACbC,IAAI,EAAG,qBADM;IAEbC,OAAO,EAAE;MACP7C,QAAQ,EAAE+B,QAAQ,CAACI,IADZ;MAEPlC,QAAQ,EAAEmC,cAFH;MAGPU,IAAI,EAAEP,YAHC;MAIPQ,YAAY,EAAE,IAAAC,oCAAA,EAAoBX,IAApB;IAJP;EAFI,CAAf;;EAUA,MAAM,IAAAY,oCAAA,EAAkBb,cAAlB,EAAkCC,IAAlC,CAAN;EACA,OAAOA,IAAP;AACD;;AAEM,eAAea,cAAf,CACLnD,SADK,EAEL;EAAEoD,kBAAF;EAAsBhC;AAAtB,CAFK,EAGLiC,iBAHK,EAIY;EACjB,MAAMlB,MAAM,GAAG5B,IAAI,CAACC,KAAL,CACb,CAAC,MAAMoB,mBAAmB,CAAE,UAASR,IAAK,EAAhB,CAA1B,EAA8CkC,QAA9C,EADa,CAAf;;EAIA,MAAMjB,cAAc,GAAGD,aAAA,CAAKmB,IAAL,CAAUvD,SAAV,EAAsB,YAAtB,EAAoC,GAAEoB,IAAK,OAA3C,CAAvB;;EAEA,MAAMoC,SAAqB,GAAG;IAC5BJ,kBAD4B;IAE5BjB,MAF4B;IAG5BkB;EAH4B,CAA9B;EAMA,MAAMf,IAAI,GAAG/B,IAAI,CAACkD,SAAL,CAAeD,SAAf,CAAb;EAEA,MAAME,aAAa,GAAGjB,MAAM,CAACC,UAAP,CAAkBJ,IAAlB,IAA0B,IAAhD;;EAEAK,YAAA,CAAMC,QAAN,CAAe;IACbC,IAAI,EAAG,sBADM;IAEbC,OAAO,EAAE;MACPa,SAAS,EAAEvC,IADJ;MAEPlB,QAAQ,EAAEmC,cAFH;MAGPU,IAAI,EAAEW,aAHC;MAIPE,aAAa,EAAE,IAAAX,oCAAA,EAAoBX,IAApB;IAJR;EAFI,CAAf;;EAUA,MAAM,IAAAY,oCAAA,EAAkBb,cAAlB,EAAkCC,IAAlC,CAAN;EACA,OAAOA,IAAP;AACD;;AAEM,eAAeuB,aAAf,CACL7D,SADK,EAEL2D,SAFK,EAG8B;EACnC,MAAMzD,QAAQ,GAAGkC,aAAA,CAAKmB,IAAL,CAAUvD,SAAV,EAAsB,YAAtB,EAAoC,GAAE2D,SAAU,OAAhD,CAAjB;;EACA,MAAMvD,WAAW,GAAG,MAAMC,gBAAA,CAAGC,QAAH,CAAYJ,QAAZ,EAAuB,OAAvB,CAA1B;EACA,OAAOK,IAAI,CAACC,KAAL,CAAWJ,WAAX,CAAP;AACD;;AAED,IAAI0D,cAAc,GAAG,KAArB;AACA,IAAIC,UAAU,GAAG,KAAjB;;AAEO,SAASC,eAAT,GAAoC;EACzC,OAAOF,cAAP;AACD;;AAYM,eAAeG,KAAf,CAAqBC,UAArB,EAAuD;EAAA;;EAC5D,IAAIH,UAAJ,EAAgB;IACd;IACA;EACD;;EACD,MAAMvC,kCAAkC,EAAxC;EACAsC,cAAc,GAAG,KAAjB;EACAC,UAAU,GAAG,IAAb;;EACA,MAAM;IACJI,qBADI;IAEJC,KAFI;IAGJC,OAHI;IAIJC,uBAJI;IAKJC,OALI;IAMJrC,MANI;IAOJsC;EAPI,IAQF7B,YAAA,CAAM8B,QAAN,EARJ;;EASA,MAAMC,OAAO,GAAG,CAAAL,OAAO,SAAP,IAAAA,OAAO,WAAP,0BAAAA,OAAO,CAAEM,CAAT,0DAAa,CAAb,OAAqB,SAArC;EAEA,MAAM;IAAEC,SAAF;IAAaC;EAAb,IAA4BV,qBAAlC;EACA,IAAIW,qBAAJ;EAEA,IAAIC,uBAAJ;;EAEA,IAAIH,SAAS,CAAC7B,IAAV,GAAiB,CAArB,EAAwB;IACtB;IACA;IACA;IACAgC,uBAAuB,GAAG,MAAM,IAAAC,kCAAA,GAAhC;EACD;;EAED,IAAIJ,SAAS,CAAC7B,IAAV,GAAiB,CAAjB,IAAsB8B,UAAU,CAAC9B,IAAX,GAAkB,CAA5C,EAA+C;IAC7C+B,qBAAqB,GAAGG,iBAAA,CAASC,cAAT,CACrB,sEADqB,EAEtBN,SAAS,CAAC7B,IAAV,GAAiB8B,UAAU,CAAC9B,IAFN,EAGtB,CAHsB,EAItB;MAAEoC,EAAE,EAAG,kCAAP;MAA0CjB;IAA1C,CAJsB,CAAxB;IAMAY,qBAAqB,CAACM,KAAtB;EACD;;EAED,MAAMC,UAAU,GAAG,IAAAC,cAAA,EAAgC,OAAOC,IAAP,EAAaC,EAAb,KAAoB;IACrE,IAAID,IAAI,CAAC1C,IAAL,KAAe,MAAnB,EAA0B;MACxB,MAAM;QAAE5C;MAAF,IAAesF,IAArB;MACA,MAAME,IAAI,GAAGrB,KAAK,CAACvC,GAAN,CAAU5B,QAAV,CAAb;MAEA,IAAIyF,uBAAuB,GAAG,IAA9B,CAJwB,CAMxB;MACA;MACA;MACA;MACA;MACA;;MACA,IAAID,IAAJ,EAAU;QACR,IAAIA,IAAI,CAACrD,IAAL,IAAa2C,uBAAjB,EAA0C;UACxCU,IAAI,CAACE,UAAL,GAAkBZ,uBAAuB,CAAClD,GAAxB,CAA4B4D,IAAI,CAACrD,IAAjC,CAAlB;QACD;;QAED,IAAI,CAACsC,OAAD,IAAYkB,OAAO,CAACC,GAAR,CAAYC,sBAA5B,EAAoD;UAClD;UACA;UACA;UACA;UACA,MAAMC,KAAK,GAAGxB,OAAO,CAACyB,cAAR,CAAuBnE,GAAvB,CAA2B4D,IAAI,CAACrD,IAAhC,CAAd;;UACA,IAAI,CAAC2D,KAAL,EAAY;YACV;YACA,MAAM,IAAIjE,KAAJ,CACH,iEADG,CAAN;UAGD;;UAED,IAAI,IAAAmE,gBAAA,EAAQF,KAAK,CAACG,KAAd,EAAqBC,4BAArB,CAAJ,EAA+C;YAC7C;YACAC,YAAY,CAAC,MAAMZ,EAAE,CAAC,IAAD,EAAO,IAAP,CAAT,CAAZ;YACA;UACD;QACF,CAvBO,CAyBR;QACA;;;QACA,IAAI,CAACd,OAAD,IAAaA,OAAO,IAAI,IAAA2B,qBAAA,EAAYZ,IAAZ,MAAuB,KAAnD,EAA0D;UACxD,MAAMpC,iBAAiB,GACrBiB,uBAAuB,CAACzC,GAAxB,CAA4B4D,IAAI,CAACa,aAAjC,KAAmD,EADrD;;UAGA,IAAI;YACF,MAAMnE,MAAM,GAAG,MAAMJ,aAAa,CAChCK,aAAA,CAAKmB,IAAL,CAAUc,OAAO,CAACkC,SAAlB,EAA8B,QAA9B,CADgC,EAEhC,EACE,GAAGd,IADL;cAEEpC;YAFF,CAFgC,EAMhCmB,gBANgC,EAOhCtC,MAPgC,CAAlC;;YAUA,IAAI,CAACwC,OAAL,EAAc;cACZ8B,kCAAA,CAAiBC,YAAjB,CAA8B;gBAC5BtB,EAAE,EAAElF,QADwB;gBAE5BkC,MAAM,EAAE5B,IAAI,CAACC,KAAL,CAAW2B,MAAX;cAFoB,CAA9B;YAID;UACF,CAjBD,CAiBE,OAAOuE,CAAP,EAAU;YACVhB,uBAAuB,GAAG,KAA1B;;YACAT,iBAAA,CAAS0B,YAAT,CACG,mCAAkClB,IAAI,CAACrD,IAAK,EAD/C,EAEEsE,CAFF;UAID;;UACD5B,qBAAqB,CAAC8B,IAAtB;QACD;MACF;;MAED,IAAIlB,uBAAJ,EAA6B;QAC3B/C,YAAA,CAAMC,QAAN,CAAe;UACbC,IAAI,EAAG,+BADM;UAEbC,OAAO,EAAE;YACP2C,IAAI,EAAExF;UADC;QAFI,CAAf;MAMD;IACF,CA/ED,MA+EO,IAAIsF,IAAI,CAAC1C,IAAL,KAAe,OAAnB,EAA2B;MAChC,MAAM;QAAEc;MAAF,IAAgB4B,IAAtB;MACA,MAAMsB,KAAK,GAAG3E,MAAM,CAACL,GAAP,CAAW8B,SAAX,CAAd;;MACA,IAAIkD,KAAJ,EAAW;QACT,MAAMxD,iBAAiB,GACrBiB,uBAAuB,CAACzC,GAAxB,CAA4BgF,KAAK,CAACP,aAAlC,KAAoD,EADtD;QAGA,MAAMnE,MAAM,GAAG,MAAMgB,cAAc,CACjCf,aAAA,CAAKmB,IAAL,CAAUc,OAAO,CAACkC,SAAlB,EAA8B,QAA9B,CADiC,EAEjCM,KAFiC,EAGjCxD,iBAHiC,CAAnC;QAMAyB,qBAAqB,CAAC8B,IAAtB;;QAEA,IAAI,CAAClC,OAAL,EAAc;UACZ8B,kCAAA,CAAiBM,aAAjB,CAA+B;YAC7B3B,EAAE,EAAExB,SADyB;YAE7BxB,MAAM,EAAE5B,IAAI,CAACC,KAAL,CAAW2B,MAAX;UAFqB,CAA/B;QAID;MACF;;MAEDQ,YAAA,CAAMC,QAAN,CAAe;QACbC,IAAI,EAAG,gCADM;QAEbC,OAAO,EAAE;UACP1B,IAAI,EAAEuC;QADC;MAFI,CAAf;IAMD,CA7GoE,CA+GrE;IACA;;;IACAyC,YAAY,CAAC,MAAMZ,EAAE,CAAC,IAAD,EAAO,IAAP,CAAT,CAAZ;IACA;EACD,CAnHkB,EAmHhB,EAnHgB,CAAnB;;EAqHA,KAAK,MAAMvF,QAAX,IAAuB2E,SAAvB,EAAkC;IAChCS,UAAU,CAAC0B,IAAX,CAAgB;MAAElE,IAAI,EAAG,MAAT;MAAgB5C;IAAhB,CAAhB,EAA4C,MAAM,CAAE,CAApD;EACD;;EACD,KAAK,MAAM0D,SAAX,IAAwBkB,UAAxB,EAAoC;IAClCQ,UAAU,CAAC0B,IAAX,CAAgB;MAAElE,IAAI,EAAG,OAAT;MAAiBc;IAAjB,CAAhB,EAA8C,MAAM,CAAE,CAAtD;EACD;;EAED,IAAI,CAAC0B,UAAU,CAAC2B,IAAX,EAAL,EAAwB;IACtB,MAAM,IAAIpG,OAAJ,CAAYC,OAAO,IAAI;MAC3BwE,UAAU,CAAC4B,KAAX,GAAmBpG,OAAnB;IACD,CAFK,CAAN;EAGD;;EACD,IAAIiE,qBAAJ,EAA2B;IACzBA,qBAAqB,CAACoC,GAAtB;EACD;;EAEDnD,UAAU,GAAG,KAAb;EAEA;AACD;;AAEM,SAASoD,YAAT,CAAsBjD,UAAtB,EAA+C;EACpD,IAAI,IAAAkD,qCAAA,GAAJ,EAA8B;IAC5BtD,cAAc,GAAG,IAAjB;EACD,CAFD,MAEO;IACLG,KAAK,CAACC,UAAD,CAAL;EACD;AACF;;AAEM,eAAemD,mBAAf,CAAmCnD,UAAnC,EAAoE;EACzE,IAAI,EAAE,MAAM7D,gBAAA,CAAGiH,UAAH,CAAe,kBAAf,CAAR,CAAJ,EAAgD;IAC9C;EACD,CAHwE,CAKzE;EACA;EACA;;;EAEA,MAAMC,QAAQ,GAAGtC,iBAAA,CAASuC,aAAT,CAAwB,6BAAxB,EAAsD;IACrEtD;EADqE,CAAtD,CAAjB;;EAGAqD,QAAQ,CAACnC,KAAT;EAEA,MAAMqC,+BAA+B,GAAG,MAAM,IAAI7G,OAAJ,CAC5C,CAACC,OAAD,EAAU6G,MAAV,KAAqB;IACnB,MAAMC,OAAO,GAAG,IAAIC,GAAJ,EAAhB;IAEA,MAAMC,MAAM,GAAG,IAAAC,cAAA,EAAc,kBAAd,CAAf;IAEAD,MAAM,CAACE,EAAP,CAAW,MAAX,EAAmBC,IAAD,IAAiB;MACjC,IAAIA,IAAI,CAAC5G,IAAL,KAAe,gBAAnB,EAAoC;QAClCuG,OAAO,CAACM,GAAR,CAAYD,IAAI,CAAC5F,IAAjB;MACD;IACF,CAJD;IAMAyF,MAAM,CAACE,EAAP,CAAW,OAAX,EAAmBrB,CAAC,IAAI;MACtBgB,MAAM,CAAChB,CAAD,CAAN;IACD,CAFD;IAIAmB,MAAM,CAACE,EAAP,CAAW,KAAX,EAAiB,MAAMlH,OAAO,CAAC8G,OAAD,CAA9B;EACD,CAjB2C,CAA9C;EAoBA,MAAMO,qBAAqB,GAAG,IAAIN,GAAJ,EAA9B;;EACAjF,YAAA,CAAM8B,QAAN,GAAiBL,KAAjB,CAAuB+D,OAAvB,CAA+B1C,IAAI,IAAI;IACrCyC,qBAAqB,CAACD,GAAtB,CAA0B,IAAA9H,qCAAA,EAAsB,QAAtB,EAA+BsF,IAAI,CAACrD,IAApC,CAA1B;EACD,CAFD;;EAIA,MAAMgG,gBAAsC,GAAG,EAA/C;EACAX,+BAA+B,CAACU,OAAhC,CAAwCE,gBAAgB,IAAI;IAC1D,IAAI,CAACH,qBAAqB,CAACI,GAAtB,CAA0BD,gBAA1B,CAAL,EAAkD;MAChDD,gBAAgB,CAACrB,IAAjB,CAAsB1G,gBAAA,CAAGM,MAAH,CAAU0H,gBAAV,CAAtB;IACD;EACF,CAJD;EAMA,MAAMzH,OAAO,CAAC2H,GAAR,CAAYH,gBAAZ,CAAN;EAEAb,QAAQ,CAACL,GAAT;AACD"}