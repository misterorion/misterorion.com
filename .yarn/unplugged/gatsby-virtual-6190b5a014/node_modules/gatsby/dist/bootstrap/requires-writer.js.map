{"version":3,"file":"requires-writer.js","names":["paramRe","SEGMENT_POINTS","STATIC_POINTS","DYNAMIC_POINTS","SPLAT_PENALTY","ROOT_POINTS","isRootSegment","segment","isDynamic","test","isSplat","hasContentFilePath","componentPath","includes","segmentize","uri","replace","split","rankRoute","path","reduce","score","lastHash","resetLastHash","pickComponentFields","page","componentChunkName","getComponents","pages","slices","values","c","getMatchPaths","createMatchPathEntry","index","matchPath","undefined","reporter","panic","matchPathPages","forEach","getPageMode","push","length","newMatches","isInsideMatchPath","find","pageWithMatchPath","match","sort","a","b","order","localeCompare","map","createHash","matchPaths","components","cleanedSSRVisitedPageComponents","crypto","update","JSON","stringify","digest","writeAll","state","program","process","env","GATSBY_EXPERIMENTAL_DEV_SSR","ssrVisitedPageComponents","visitedPages","get","filter","some","s","newHash","lazySyncRequires","joinPath","join","writeModule","devSSRWillInvalidate","syncRequires","asyncRequires","gatsby_executing_command","GATSBY_PARTIAL_HYDRATION","relativeComponentPath","relative","getAbsolutePathForVirtualModule","rqPrefix","slash","writeAndMove","virtualFilePath","file","data","destination","directory","tmp","Date","now","fs","writeFile","then","move","overwrite","Promise","all","debouncedWriteAll","activity","activityTimer","id","start","store","getState","end","leading","listenerStarted","startListener","emitter","on","pendingActivity"],"sources":["../../src/bootstrap/requires-writer.ts"],"sourcesContent":["import _ from \"lodash\"\nimport path from \"path\"\nimport fs from \"fs-extra\"\nimport crypto from \"crypto\"\nimport { slash } from \"gatsby-core-utils\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { match } from \"@gatsbyjs/reach-router\"\nimport { joinPath } from \"gatsby-core-utils\"\nimport { store, emitter } from \"../redux/\"\nimport { IGatsbyState, IGatsbyPage, IGatsbySlice } from \"../redux/types\"\nimport {\n  writeModule,\n  getAbsolutePathForVirtualModule,\n} from \"../utils/gatsby-webpack-virtual-modules\"\nimport { getPageMode } from \"../utils/page-mode\"\nimport { devSSRWillInvalidate } from \"../commands/build-html\"\n\ninterface IGatsbyPageComponent {\n  componentPath: string\n  componentChunkName: string\n}\n\ninterface IGatsbyPageMatchPath {\n  path: string\n  matchPath: string | undefined\n}\n\n// path ranking algorithm copied (with small adjustments) from `@reach/router` (internal util, not exported from the package)\n// https://github.com/reach/router/blob/28a79e7fc3a3487cb3304210dc3501efb8a50eba/src/lib/utils.js#L216-L254\nconst paramRe = /^:(.+)/\n\nconst SEGMENT_POINTS = 4\nconst STATIC_POINTS = 3\nconst DYNAMIC_POINTS = 2\nconst SPLAT_PENALTY = 1\nconst ROOT_POINTS = 1\n\nconst isRootSegment = (segment: string): boolean => segment === ``\nconst isDynamic = (segment: string): boolean => paramRe.test(segment)\nconst isSplat = (segment: string): boolean => segment === `*`\nconst hasContentFilePath = (componentPath: string): boolean =>\n  componentPath.includes(`?__contentFilePath=`)\n\nconst segmentize = (uri: string): Array<string> =>\n  uri\n    // strip starting/ending slashes\n    .replace(/(^\\/+|\\/+$)/g, ``)\n    .split(`/`)\n\nconst rankRoute = (path: string): number =>\n  segmentize(path).reduce((score, segment) => {\n    score += SEGMENT_POINTS\n    if (isRootSegment(segment)) score += ROOT_POINTS\n    else if (isDynamic(segment)) score += DYNAMIC_POINTS\n    else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY\n    else score += STATIC_POINTS\n    return score\n  }, 0)\n// end of copied `@reach/router` internals\n\nlet lastHash: string | null = null\n\nexport const resetLastHash = (): void => {\n  lastHash = null\n}\n\ntype IBareComponentData = Pick<\n  IGatsbyPageComponent,\n  `componentPath` | `componentChunkName`\n>\nconst pickComponentFields = (\n  page: IGatsbyPage | IGatsbySlice\n): IBareComponentData => {\n  return {\n    componentPath: page.componentPath,\n    componentChunkName: page.componentChunkName,\n  }\n}\n\nexport const getComponents = (\n  pages: Array<IGatsbyPage>,\n  slices: IGatsbyState[\"slices\"]\n): Array<IGatsbyPageComponent> =>\n  _.orderBy(\n    _.uniqBy(\n      _.map([...pages, ...slices.values()], pickComponentFields),\n      c => c.componentChunkName\n    ),\n    c => c.componentChunkName\n  )\n\n/**\n * Get all dynamic routes and sort them by most specific at the top\n * code is based on @reach/router match utility (https://github.com/reach/router/blob/152aff2352bc62cefc932e1b536de9efde6b64a5/src/lib/utils.js#L224-L254)\n */\nconst getMatchPaths = (\n  pages: Array<IGatsbyPage>\n): Array<IGatsbyPageMatchPath> => {\n  interface IMatchPathEntry extends IGatsbyPage {\n    index: number\n    score: number\n    matchPath: string\n  }\n\n  const createMatchPathEntry = (\n    page: IGatsbyPage,\n    index: number\n  ): IMatchPathEntry => {\n    const { matchPath } = page\n\n    if (matchPath === undefined) {\n      return reporter.panic(\n        `Error: matchPath property is undefined for page ${page.path}, should be a string`\n      ) as never\n    }\n\n    return {\n      ...page,\n      matchPath,\n      index,\n      score: rankRoute(matchPath),\n    }\n  }\n\n  const matchPathPages: Array<IMatchPathEntry> = []\n\n  pages.forEach((page: IGatsbyPage, index: number): void => {\n    if (page.matchPath && getPageMode(page) === `SSG`) {\n      matchPathPages.push(createMatchPathEntry(page, index))\n    }\n  })\n\n  // Pages can live in matchPaths, to keep them working without doing another network request\n  // we save them in matchPath. We use `@reach/router` path ranking to score paths/matchPaths\n  // and sort them so more specific paths are before less specific paths.\n  // More info in https://github.com/gatsbyjs/gatsby/issues/16097\n  // small speedup: don't bother traversing when no matchPaths found.\n  if (matchPathPages.length) {\n    const newMatches: Array<IMatchPathEntry> = []\n\n    pages.forEach((page: IGatsbyPage, index: number): void => {\n      const isInsideMatchPath = !!matchPathPages.find(\n        pageWithMatchPath =>\n          !page.matchPath && match(pageWithMatchPath.matchPath, page.path)\n      )\n\n      if (isInsideMatchPath) {\n        newMatches.push(\n          createMatchPathEntry(\n            {\n              ...page,\n              matchPath: page.path,\n            },\n            index\n          )\n        )\n      }\n    })\n    // Add afterwards because the new matches are not relevant for the existing search\n    matchPathPages.push(...newMatches)\n  }\n\n  return matchPathPages\n    .sort((a, b) => {\n      // The higher the score, the higher the specificity of our matchPath\n      const order = b.score - a.score\n      if (order !== 0) {\n        return order\n      }\n\n      // if specificity is the same we do lexigraphic comparison of path to ensure\n      // deterministic order regardless of order pages where created\n      return a.matchPath.localeCompare(b.matchPath)\n    })\n    .map(({ path, matchPath }) => {\n      return { path, matchPath }\n    })\n}\n\nconst createHash = (\n  matchPaths: Array<IGatsbyPageMatchPath>,\n  components: Array<IGatsbyPageComponent>,\n  cleanedSSRVisitedPageComponents: Array<IGatsbyPageComponent>\n): string =>\n  crypto\n    .createHash(`md5`)\n    .update(\n      JSON.stringify({\n        matchPaths,\n        components,\n        cleanedSSRVisitedPageComponents,\n      })\n    )\n    .digest(`hex`)\n\n// Write out pages information.\nexport const writeAll = async (state: IGatsbyState): Promise<boolean> => {\n  const { program, slices } = state\n  const pages = [...state.pages.values()]\n  const matchPaths = getMatchPaths(pages)\n  const components = getComponents(pages, slices)\n  let cleanedSSRVisitedPageComponents: Array<IGatsbyPageComponent> = []\n\n  if (process.env.GATSBY_EXPERIMENTAL_DEV_SSR) {\n    const ssrVisitedPageComponents = [\n      ...(state.visitedPages.get(`server`)?.values() || []),\n    ]\n\n    // Remove any page components that no longer exist.\n    cleanedSSRVisitedPageComponents = components.filter(c =>\n      ssrVisitedPageComponents.some(s => s === c.componentChunkName)\n    )\n  }\n\n  const newHash = createHash(\n    matchPaths,\n    components,\n    cleanedSSRVisitedPageComponents\n  )\n\n  if (newHash === lastHash) {\n    // Nothing changed. No need to rewrite files\n    return false\n  }\n\n  lastHash = newHash\n\n  if (process.env.GATSBY_EXPERIMENTAL_DEV_SSR) {\n    // Create file with sync requires of visited page components files.\n\n    const lazySyncRequires = `exports.ssrComponents = {\\n${cleanedSSRVisitedPageComponents\n      .map(\n        (c: IGatsbyPageComponent): string =>\n          `  \"${c.componentChunkName}\": require(\"${joinPath(c.componentPath)}\")`\n      )\n      .join(`,\\n`)}\n  }\\n\\n`\n\n    writeModule(`$virtual/ssr-sync-requires`, lazySyncRequires)\n    // if this is executed, webpack should mark it as invalid, but sometimes there is some timing race\n    // so we also explicitly set flag here as well\n    devSSRWillInvalidate()\n  }\n\n  // Create file with sync requires of components/json files.\n  let syncRequires = `\n// prefer default export if available\nconst preferDefault = m => (m && m.default) || m\n\\n\\n`\n  syncRequires += `exports.components = {\\n${components\n    .map(\n      (c: IGatsbyPageComponent): string =>\n        `  \"${c.componentChunkName}\": preferDefault(require(\"${joinPath(\n          c.componentPath\n        )}\"))`\n    )\n    .join(`,\\n`)}\n}\\n\\n`\n\n  // Create file with async requires of components/json files.\n  let asyncRequires = ``\n\n  if (\n    process.env.gatsby_executing_command === `develop` ||\n    (_CFLAGS_.GATSBY_MAJOR === `5` && process.env.GATSBY_PARTIAL_HYDRATION)\n  ) {\n    asyncRequires = `exports.components = {\\n${components\n      .map((c: IGatsbyPageComponent): string => {\n        // we need a relative import path to keep contenthash the same if directory changes\n        const relativeComponentPath = path.relative(\n          getAbsolutePathForVirtualModule(`$virtual`),\n          c.componentPath\n        )\n\n        const rqPrefix = hasContentFilePath(relativeComponentPath) ? `&` : `?`\n\n        return `  \"${c.componentChunkName}\": () => import(\"${slash(\n          `./${relativeComponentPath}`\n        )}${rqPrefix}export=default\" /* webpackChunkName: \"${\n          c.componentChunkName\n        }\" */)`\n      })\n      .join(`,\\n`)}\n}\\n\\n\n\nexports.head = {\\n${components\n      .map((c: IGatsbyPageComponent): string => {\n        // we need a relative import path to keep contenthash the same if directory changes\n        const relativeComponentPath = path.relative(\n          getAbsolutePathForVirtualModule(`$virtual`),\n          c.componentPath\n        )\n\n        const rqPrefix = hasContentFilePath(relativeComponentPath) ? `&` : `?`\n\n        return `  \"${c.componentChunkName}\": () => import(\"${slash(\n          `./${relativeComponentPath}`\n        )}${rqPrefix}export=head\" /* webpackChunkName: \"${\n          c.componentChunkName\n        }head\" */)`\n      })\n      .join(`,\\n`)}\n}\\n\\n`\n  } else {\n    asyncRequires = `exports.components = {\\n${components\n      .map((c: IGatsbyPageComponent): string => {\n        // we need a relative import path to keep contenthash the same if directory changes\n        const relativeComponentPath = path.relative(\n          getAbsolutePathForVirtualModule(`$virtual`),\n          c.componentPath\n        )\n        return `  \"${c.componentChunkName}\": () => import(\"${slash(\n          `./${relativeComponentPath}`\n        )}\" /* webpackChunkName: \"${c.componentChunkName}\" */)`\n      })\n      .join(`,\\n`)}\n}\\n\\n`\n  }\n\n  const writeAndMove = (\n    virtualFilePath: string,\n    file: string,\n    data: string\n  ): Promise<void> => {\n    writeModule(virtualFilePath, data)\n\n    // files in .cache are not used anymore as part of webpack builds, but\n    // still can be used by other tools (for example `gatsby serve` reads\n    // `match-paths.json` to setup routing)\n    const destination = joinPath(program.directory, `.cache`, file)\n    const tmp = `${destination}.${Date.now()}`\n    return fs\n      .writeFile(tmp, data)\n      .then(() => fs.move(tmp, destination, { overwrite: true }))\n  }\n\n  await Promise.all([\n    writeAndMove(`$virtual/sync-requires.js`, `sync-requires.js`, syncRequires),\n    writeAndMove(\n      `$virtual/async-requires.js`,\n      `async-requires.js`,\n      asyncRequires\n    ),\n    writeAndMove(\n      `$virtual/match-paths.json`,\n      `match-paths.json`,\n      JSON.stringify(matchPaths, null, 4)\n    ),\n  ])\n\n  return true\n}\n\nconst debouncedWriteAll = _.debounce(\n  async (): Promise<void> => {\n    const activity = reporter.activityTimer(`write out requires`, {\n      id: `requires-writer`,\n    })\n    activity.start()\n    await writeAll(store.getState())\n    activity.end()\n  },\n  500,\n  {\n    // using \"leading\" can cause double `writeAll` call - particularly\n    // when refreshing data using `/__refresh` hook.\n    leading: false,\n  }\n)\n\n/**\n * Start listening to CREATE/DELETE_PAGE events so we can rewrite\n * files as required\n */\nlet listenerStarted = false\nexport const startListener = (): void => {\n  // Only start the listener once.\n  if (listenerStarted) {\n    return\n  }\n  listenerStarted = true\n\n  if (process.env.GATSBY_EXPERIMENTAL_DEV_SSR) {\n    /**\n     * Start listening to CREATE_SERVER_VISITED_PAGE events so we can rewrite\n     * files as required\n     */\n    emitter.on(`CREATE_SERVER_VISITED_PAGE`, async (): Promise<void> => {\n      // this event only happen on new additions\n      devSSRWillInvalidate()\n      reporter.pendingActivity({ id: `requires-writer` })\n      debouncedWriteAll()\n    })\n  }\n\n  emitter.on(`CREATE_PAGE`, (): void => {\n    reporter.pendingActivity({ id: `requires-writer` })\n    debouncedWriteAll()\n  })\n\n  emitter.on(`CREATE_PAGE_END`, (): void => {\n    reporter.pendingActivity({ id: `requires-writer` })\n    debouncedWriteAll()\n  })\n\n  emitter.on(`DELETE_PAGE`, (): void => {\n    reporter.pendingActivity({ id: `requires-writer` })\n    debouncedWriteAll()\n  })\n\n  emitter.on(`DELETE_PAGE_BY_PATH`, (): void => {\n    reporter.pendingActivity({ id: `requires-writer` })\n    debouncedWriteAll()\n  })\n}\n"],"mappings":"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"}