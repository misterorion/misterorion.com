{"version":3,"file":"stitching.js","names":["ensureExpectedType","maybeType","Error","stitchSlices","htmlString","publicDir","previousStart","undefined","processedHTML","cursor","getSliceContent","sliceHtmlName","fs","readFile","path","join","match","matchAll","groups","index","startOrEndElementOpenening","startOrEndElementClosing","meta","end","length","syntax","id","idElement","type","idComment","startOrEndComment","newCursor","substring","stitchSliceForAPage","pagePath","htmlFilePath","generateHtmlPath","html","writeFile"],"sources":["../../../src/utils/slices/stitching.ts"],"sourcesContent":["import * as path from \"path\"\nimport * as fs from \"fs-extra\"\nimport { generateHtmlPath } from \"gatsby-core-utils/page-html\"\n\ninterface ISliceBoundaryMatch {\n  index: number\n  end: number\n  syntax: \"element\" | \"comment\"\n  id: string\n  type: \"start\" | \"end\"\n}\n\nfunction ensureExpectedType(maybeType: string): \"start\" | \"end\" {\n  if (maybeType === `start` || maybeType === `end`) {\n    return maybeType\n  } else {\n    throw new Error(`Unexpected type: ${maybeType}. Expected \"start\" or \"end\"`)\n  }\n}\n\nasync function stitchSlices(\n  htmlString: string,\n  publicDir: string\n): Promise<string> {\n  let previousStart: ISliceBoundaryMatch | undefined = undefined\n\n  let processedHTML = ``\n  let cursor = 0\n\n  async function getSliceContent(sliceHtmlName: string): Promise<string> {\n    return fs.readFile(\n      path.join(publicDir, `_gatsby`, `slices`, `${sliceHtmlName}.html`),\n      `utf-8`\n    )\n  }\n\n  for (const match of htmlString.matchAll(\n    /(<slice-(?<startOrEndElementOpenening>start|end)\\s[^>]*id=\"(?<idElement>[^\"]+)\"[^>]*><\\/slice-(?<startOrEndElementClosing>[^>]+)>|<!-- slice-(?<startOrEndComment>start|end) id=\"(?<idComment>[^\"]+)\" -->)/g\n  )) {\n    if (!match.groups) {\n      throw new Error(\n        `Invariant: [stitching slices] Capturing groups should be defined`\n      )\n    }\n\n    if (typeof match.index !== `number`) {\n      throw new Error(\n        `Invariant: [stitching slices] There is no location of a match when stitching slices`\n      )\n    }\n\n    if (\n      match.groups.startOrEndElementOpenening &&\n      match.groups.startOrEndElementOpenening !==\n        match.groups.startOrEndElementClosing\n    ) {\n      throw new Error(\n        `Invariant: [stitching slices] start and end tags should be the same. Got: Start: ${match.groups.startOrEndElementOpenening} End: ${match.groups.startOrEndElementClosing}`\n      )\n    }\n\n    const meta: ISliceBoundaryMatch = {\n      index: match.index,\n      end: match.index + match[0].length,\n      ...(match.groups.startOrEndElementOpenening\n        ? {\n            syntax: `element`, // can discard this field\n            id: match.groups.idElement,\n            type: ensureExpectedType(match.groups.startOrEndElementOpenening),\n          }\n        : {\n            syntax: `comment`, // can discard this field\n            id: match.groups.idComment,\n            type: ensureExpectedType(match.groups.startOrEndComment),\n          }),\n    }\n\n    if (meta.type === `start`) {\n      if (previousStart) {\n        // if we are already in a slice, we will replace everything until the outer slice end\n        // so we just ignore those\n        continue\n      }\n      const newCursor = meta.end\n      processedHTML +=\n        htmlString.substring(cursor, meta.index) +\n        `<!-- slice-start id=\"${meta.id}\" -->`\n      cursor = newCursor\n\n      previousStart = meta\n    } else if (meta.type === `end`) {\n      if (!previousStart) {\n        throw new Error(\n          `Invariant: [stitching slices] There was no start tag, but close tag was found`\n        )\n      }\n      if (previousStart.id !== meta.id) {\n        // it's possible to have nested slices - we want to handle just the most outer slice\n        // as stitching it in will recursively handle nested slices as well\n        continue\n      }\n\n      processedHTML += `${await stitchSlices(\n        await getSliceContent(meta.id),\n        publicDir\n      )}<!-- slice-end id=\"${meta.id}\" -->`\n      cursor = meta.end\n\n      previousStart = undefined\n    }\n  }\n\n  if (previousStart) {\n    throw new Error(\n      `Invariant: [stitching slices] There was start tag, but no close tag was found`\n    )\n  }\n\n  // get rest of the html\n  processedHTML += htmlString.substring(cursor)\n\n  return processedHTML\n}\n\nexport async function stitchSliceForAPage({\n  pagePath,\n  publicDir,\n}: {\n  pagePath: string\n  publicDir: string\n}): Promise<void> {\n  const htmlFilePath = generateHtmlPath(publicDir, pagePath)\n\n  const html = await fs.readFile(htmlFilePath, `utf-8`)\n\n  const processedHTML = await stitchSlices(html, publicDir)\n\n  if (html !== processedHTML) {\n    await fs.writeFile(htmlFilePath, processedHTML)\n  }\n}\n"],"mappings":"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"}